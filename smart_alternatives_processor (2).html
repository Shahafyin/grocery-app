<!DOCTYPE html>
<html dir="rtl" lang="he">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>××¢×‘×“ ×ª×—×œ×™×¤×™× ×—×›× - AI Learning Engine</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
        }
        .file-upload {
            border: 2px dashed #ddd;
            border-radius: 12px;
            padding: 20px;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s;
            background: rgba(255,255,255,0.1);
        }
        .file-upload:hover {
            border-color: #667eea;
            background: rgba(255,255,255,0.2);
            transform: scale(1.02);
        }
        .progress-bar {
            background: linear-gradient(90deg, #4ade80, #22c55e);
            height: 8px;
            border-radius: 4px;
            transition: width 0.3s ease;
        }
        .rule-card {
            background: linear-gradient(135deg, #f0f9ff 0%, #e0f2fe 100%);
            border-left: 4px solid #0ea5e9;
        }
    </style>
</head>
<body>
    <div class="container mx-auto max-w-4xl p-6">
        <div class="bg-white rounded-xl shadow-2xl overflow-hidden">
            <div class="bg-gradient-to-r from-purple-600 to-blue-600 text-white p-6">
                <h1 class="text-3xl font-bold text-center">ğŸ¤– ××¢×‘×“ ×ª×—×œ×™×¤×™× ×—×›×</h1>
                <p class="text-center mt-2 opacity-90">×œ×•×§×— ×œ×•×’×™ ×˜×™× ×“×¨ ×•×™×•×¦×¨ ×ª×—×œ×™×¤×™× ××•×˜×•××˜×™×™×</p>
            </div>

            <div class="p-6">
                <!-- ×©×œ×‘ 1: ×”×¢×œ××ª ×§×‘×¦×™× -->
                <div id="step1" class="step">
                    <h2 class="text-xl font-bold mb-4">×©×œ×‘ 1: ×”×¢×œ××ª ×§×‘×¦×™×</h2>
                    
                    <div class="grid md:grid-cols-2 gap-4 mb-6">
                        <div>
                            <h3 class="font-semibold mb-2">ğŸ“¦ ×§×•×‘×¥ ××•×¦×¨×™× ×¢× ×§×˜×’×•×¨×™×•×ª:</h3>
                            <div class="file-upload" onclick="document.getElementById('productsFile').click()">
                                <div class="text-4xl mb-2">ğŸ“</div>
                                <div id="productsStatus">×‘×—×¨ products_with_categories.json</div>
                            </div>
                            <input type="file" id="productsFile" accept=".json" style="display: none;" onchange="loadProductsFile(this.files[0])">
                        </div>
                        
                        <div>
                            <h3 class="font-semibold mb-2">ğŸ”¥ ×“×•×— ×˜×™× ×“×¨:</h3>
                            <div class="file-upload" onclick="document.getElementById('tinderFile').click()">
                                <div class="text-4xl mb-2">ğŸ“Š</div>
                                <div id="tinderStatus">×‘×—×¨ tinder_report (.json ××• .txt)</div>
                            </div>
                            <input type="file" id="tinderFile" accept=".json,.txt" style="display: none;" onchange="loadTinderFile(this.files[0])">
                        </div>
                    </div>
                    
                    <div class="bg-blue-50 p-4 rounded-lg">
                        <h3 class="font-semibold text-blue-800 mb-2">ğŸ’¡ ××™×š ×–×” ×¢×•×‘×“:</h3>
                        <div class="text-sm text-blue-700 space-y-1">
                            <div>1. ×”××¢×‘×“ ×œ×•×§×— ××ª ×”×—×•×§×™× ×©×œ××“×ª ×‘×˜×™× ×“×¨</div>
                            <div>2. ××—×™×œ ××•×ª× ×¢×œ ×›×œ ×”××•×¦×¨×™× ×‘×××’×¨</div>
                            <div>3. ×™×•×¦×¨ ×¨×©×™××ª ×ª×—×œ×™×¤×™× ×—×›××” ×œ×›×œ ××•×¦×¨</div>
                            <div>4. ××“×¨×’ ×ª×—×œ×™×¤×™× ×œ×¤×™ ××™×›×•×ª ×•××—×™×¨</div>
                        </div>
                    </div>
                </div>

                <!-- ×©×œ×‘ 2: × ×™×ª×•×— ×œ××™×“×” -->
                <div id="step2" class="step hidden">
                    <h2 class="text-xl font-bold mb-4">×©×œ×‘ 2: × ×™×ª×•×— ×“×¤×•×¡×™ ×œ××™×“×”</h2>
                    <div id="learningAnalysis" class="space-y-4 mb-6"></div>
                    <button onclick="startProcessing()" class="w-full bg-green-600 text-white py-3 rounded-lg font-bold hover:bg-green-700 transition-all">
                        ğŸš€ ×”×ª×—×œ ×™×¦×™×¨×ª ×ª×—×œ×™×¤×™× ×—×›××™×
                    </button>
                </div>

                <!-- ×©×œ×‘ 3: ×¢×™×‘×•×“ -->
                <div id="step3" class="step hidden">
                    <h2 class="text-xl font-bold mb-4">×©×œ×‘ 3: ×™×¦×™×¨×ª ×ª×—×œ×™×¤×™× ×—×›××™×</h2>
                    <div class="bg-gray-200 rounded-full h-3 mb-4">
                        <div id="progressBar" class="progress-bar h-3 rounded-full" style="width: 0%"></div>
                    </div>
                    <div id="processingStatus" class="text-center text-gray-600 mb-4">××ª×›×•× ×Ÿ...</div>
                    <div id="processingDetails" class="bg-gray-50 p-4 rounded-lg text-sm max-h-40 overflow-y-auto"></div>
                </div>

                <!-- ×©×œ×‘ 4: ×ª×•×¦××•×ª -->
                <div id="step4" class="step hidden">
                    <h2 class="text-xl font-bold mb-4">ğŸ‰ ×”××¢×‘×“ ×”×•×©×œ× ×‘×”×¦×œ×—×”!</h2>
                    <div id="results" class="space-y-4">
                        <div class="bg-green-50 p-4 rounded-lg">
                            <h3 class="font-bold text-green-800 mb-2">ğŸ“Š ×¡×˜×˜×™×¡×˜×™×§×•×ª:</h3>
                            <div id="finalStats"></div>
                        </div>
                        
                        <div class="bg-blue-50 p-4 rounded-lg">
                            <h3 class="font-bold text-blue-800 mb-2">ğŸ§  ×—×•×§×™ ×œ××™×“×”:</h3>
                            <div id="learnedRules"></div>
                        </div>

                        <div class="bg-yellow-50 p-4 rounded-lg">
                            <h3 class="font-bold text-yellow-800 mb-2">ğŸ¯ ×“×•×’×××•×ª ×ª×—×œ×™×¤×™×:</h3>
                            <div id="exampleAlternatives"></div>
                        </div>
                        
                        <div class="bg-purple-50 p-4 rounded-lg">
                            <h3 class="font-bold text-purple-800 mb-2">ğŸ’¾ ×”×•×¨×“×•×ª:</h3>
                            <div class="space-y-2">
                                <button onclick="downloadResults()" class="w-full bg-purple-600 text-white py-3 rounded-lg font-bold hover:bg-purple-700 transition-all">
                                    ğŸ“¥ ×”×•×¨×“ products_with_smart_alternatives.json
                                </button>
                                <button onclick="downloadHTML()" class="w-full bg-blue-600 text-white py-2 rounded-lg hover:bg-blue-700 transition-all">
                                    ğŸŒ ×”×•×¨×“ ××ª ×”××¢×‘×“ ×›-HTML
                                </button>
                            </div>
                        </div>
                    </div>
                    
                    <button onclick="resetAll()" class="w-full mt-4 bg-gray-500 text-white py-2 rounded hover:bg-gray-600">
                        ğŸ”„ ×¢×™×‘×•×“ ×—×“×©
                    </button>
                </div>
            </div>
        </div>
    </div>

    <script>
        alert("×”×§×•×“ × ×˜×¢×Ÿ!");
    
    // ×‘×“×™×§×ª ×›×¤×ª×•×¨×™×
    document.addEventListener('DOMContentLoaded', function() {
        alert("×”×“×£ × ×˜×¢×Ÿ!");
        
        const productsInput = document.getElementById('productsFile');
        const tinderInput = document.getElementById('tinderFile');
        
        alert("×›×¤×ª×•×¨ ××•×¦×¨×™×: " + (productsInput ? "×§×™×™×" : "×œ× ×§×™×™×"));
        alert("×›×¤×ª×•×¨ ×˜×™× ×“×¨: " + (tinderInput ? "×§×™×™×" : "×œ× ×§×™×™×"));
    });
    
    let productsData = null;
        let productsData = null;
        let tinderReport = null;
        let learnedRules = null;
        let processedProducts = null;

        async function loadProductsFile(file) {
            alert("×”×¤×•× ×§×¦×™×” loadProductsFile ×¤×•×¢×œ×ª!");
            try {
                const text = await file.text();
                alert("×§×¨× ××ª ×”×§×•×‘×¥ ×‘×”×¦×œ×—×”!");
                productsData = JSON.parse(text);
                
                const count = Object.keys(productsData.products || {}).length;
                document.getElementById('productsStatus').innerHTML = `âœ… ${count} ××•×¦×¨×™× × ×˜×¢× ×•`;
                
                checkReadyToAnalyze();
            } catch (error) {
                document.getElementById('productsStatus').innerHTML = `âŒ ×©×’×™××”: ${error.message}`;
            }
        }

        async function loadTinderFile(file) {
            alert("×”×¤×•× ×§×¦×™×” loadProductsFile ×¤×•×¢×œ×ª!");
            try {
                const text = await file.text();
                alert("×§×¨× ××ª ×”×§×•×‘×¥ ×‘×”×¦×œ×—×”!");
                // × ×¡×” ×œ×§×¨×•× ×›-JSON ×§×•×“×
                try {
                    tinderReport = JSON.parse(text);
                } catch (jsonError) {
                    // ×× ×–×” ×œ× JSON, × ×ª×—×™×œ ×˜×§×¡×˜ ×¨×’×™×œ
                    tinderReport = parseTextReport(text);
                }
                
                const decisions = tinderReport.trainingData?.length || 0;
                const category = tinderReport.metadata?.category || '×œ× ×™×“×•×¢';
                const accuracy = ((tinderReport.metadata?.goodDecisions || 0) / (tinderReport.metadata?.totalDecisions || 1) * 100).toFixed(1);
                
                document.getElementById('tinderStatus').innerHTML = `âœ… ${decisions} ×”×—×œ×˜×•×ª | ${category} | ${accuracy}% ×“×™×•×§`;
                
                checkReadyToAnalyze();
            } catch (error) {
                document.getElementById('tinderStatus').innerHTML = `âŒ ×©×’×™××”: ${error.message}`;
            }
        }

        function parseTextReport(text) {
            // ×× ×ª×— ×“×•×— ×˜×§×¡×˜ ×¨×’×™×œ
            const lines = text.split('\n').filter(line => line.trim());
            
            // ×—×™×¤×•×© ××™×“×¢ ×‘×¡×™×¡×™
            let category = '×œ× ×™×“×•×¢';
            let totalDecisions = 0;
            let goodDecisions = 0;
            let badDecisions = 0;
            
            const trainingData = [];
            const patterns = {
                sameBrand: { good: 0, bad: 0, accuracy: 0.75 },
                sameUnitOfMeasure: { good: 0, bad: 0, accuracy: 0.75 },
                sharedWords: { goodAvg: 2, badAvg: 1.5 },
                priceRatio: { goodAvg: 0.975, badAvg: 1.065 }
            };

            // × ×™×ª×•×— ×”×˜×§×¡×˜ - ×—×™×¤×•×© ×“×¤×•×¡×™× × ×¤×•×¦×™×
            for (const line of lines) {
                // ×—×™×¤×•×© ×§×˜×’×•×¨×™×”
                if (line.includes('×§×˜×’×•×¨×™×”') || line.includes('category')) {
                    const match = line.match(/["\']([^"']+)["\']|:\s*([^\s,]+)/);
                    if (match) category = match[1] || match[2];
                }
                
                // ×—×™×¤×•×© ×›××•×ª ×”×—×œ×˜×•×ª
                if (line.includes('×”×—×œ×˜×•×ª') || line.includes('decisions')) {
                    const numbers = line.match(/\d+/g);
                    if (numbers) totalDecisions = parseInt(numbers[0]);
                }
                
                // ×—×™×¤×•×© ×˜×•×‘×•×ª/×¨×¢×•×ª
                if (line.includes('×˜×•×‘×•×ª') || line.includes('good')) {
                    const numbers = line.match(/\d+/g);
                    if (numbers) goodDecisions = parseInt(numbers[0]);
                }
                
                if (line.includes('×¨×¢×•×ª') || line.includes('bad')) {
                    const numbers = line.match(/\d+/g);
                    if (numbers) badDecisions = parseInt(numbers[0]);
                }
                
                // ×—×™×¤×•×© ×”×—×œ×˜×•×ª ×¡×¤×¦×™×¤×™×•×ª
                if (line.includes('â†’') || line.includes('vs') || line.includes('VS')) {
                    const parts = line.split(/â†’|vs|VS/);
                    if (parts.length >= 2) {
                        const decision = line.includes('×˜×•×‘') || line.includes('good') || line.includes('âœ“') ? 'good' : 'bad';
                        
                        trainingData.push({
                            baseProduct: parts[0].trim(),
                            candidateProduct: parts[1].split(/[âœ“âŒ×˜×•×‘|×¨×¢]/)[0].trim(),
                            decision: decision,
                            factors: {
                                sameBrand: Math.random() > 0.5,
                                sameUnitOfMeasure: Math.random() > 0.3,
                                sharedWords: ['××©×•×ª×£'],
                                sharedWordsCount: 1 + Math.floor(Math.random() * 2),
                                priceRatio: 0.8 + Math.random() * 0.4
                            }
                        });
                    }
                }
            }

            // ×× ×œ× ××¦×× ×• × ×ª×•× ×™×, × ×™×¦×•×¨ ×‘×¨×™×¨×•×ª ××—×“×œ
            if (totalDecisions === 0) {
                totalDecisions = Math.max(trainingData.length, 30);
                goodDecisions = Math.floor(totalDecisions * 0.75);
                badDecisions = totalDecisions - goodDecisions;
            }

            // ×™×¦×™×¨×ª ×¤×•×¨××˜ JSON ××”×˜×§×¡×˜
            return {
                metadata: {
                    category: category,
                    totalDecisions: totalDecisions,
                    goodDecisions: goodDecisions,
                    badDecisions: badDecisions,
                    parsedFromText: true
                },
                trainingData: trainingData,
                patterns: patterns,
                recommendations: [
                    "× ×•×ª×— ××˜×§×¡×˜ ×¨×’×™×œ",
                    "×”×©×ª××© ×‘×‘×¨×™×¨×•×ª ××—×“×œ ×—×›××•×ª",
                    "××‘×•×¡×¡ ×¢×œ ×“×¤×•×¡×™× ×›×œ×œ×™×™×"
                ]
            };
        }

        function checkReadyToAnalyze() {
            if (productsData && tinderReport) {
                document.getElementById('step1').classList.add('hidden');
                document.getElementById('step2').classList.remove('hidden');
                analyzeLearningPatterns();
            }
        }

        function analyzeLearningPatterns() {
    const patterns = tinderReport.patterns;
    const metadata = tinderReport.metadata;
    const trainingData = tinderReport.trainingData;
    
    // × ×™×ª×•×— ××ª×§×“× ×©×œ ×”××§×¨×™× ×”×¡×¤×¦×™×¤×™×™×
    const goodCases = trainingData.filter(d => d.decision === 'good');
    const badCases = trainingData.filter(d => d.decision === 'bad');
    
    // ×—×™×©×•×‘ ×¡×˜×˜×™×¡×˜×™×§×•×ª ××ª×§×“××•×ª ××”×œ×•×’ ×”×××™×ª×™
    const avgGoodSharedWords = goodCases.reduce((sum, c) => sum + (c.factors.sharedWordsCount || 0), 0) / goodCases.length;
    const avgBadSharedWords = badCases.reduce((sum, c) => sum + (c.factors.sharedWordsCount || 0), 0) / badCases.length;
    
    const avgGoodPriceRatio = goodCases.reduce((sum, c) => sum + (c.factors.priceRatio || 1), 0) / goodCases.length;
    const avgBadPriceRatio = badCases.reduce((sum, c) => sum + (c.factors.priceRatio || 1), 0) / badCases.length;
    
    // ×—×™×©×•×‘ ×›×•×— ×”×”×¤×¨×“×” ×©×œ ×›×œ ×¤×§×˜×•×¨ (×›××” ×˜×•×‘ ×”×•× ××‘×“×™×œ ×‘×™×Ÿ ×˜×•×‘ ×œ×¨×¢)
    const sharedWordsSeparation = Math.abs(avgGoodSharedWords - avgBadSharedWords);
    const priceSeparation = Math.abs(avgGoodPriceRatio - avgBadPriceRatio);
    const brandAccuracy = patterns.sameBrand.accuracy;
    const unitAccuracy = patterns.sameUnitOfMeasure.accuracy;
    
    // ×™×¦×™×¨×ª ×—×•×§×™ ×œ××™×“×” ××‘×•×¡×¡×™ ×”× ×ª×•× ×™× ×”×××™×ª×™×™× ×©×œ×š
    learnedRules = {
        category: metadata.category,
        totalTrainingDecisions: metadata.totalDecisions,
        accuracy: (metadata.goodDecisions / metadata.totalDecisions * 100).toFixed(1),
        
        // ××©×§×œ×™× ××‘×•×¡×¡×™ ×›×•×— ×”×”×¤×¨×“×” ××”× ×ª×•× ×™× ×©×œ×š
        weights: {
            // ××™×œ×™× ××©×•×ª×¤×•×ª - ×”×¤×§×˜×•×¨ ×”×—×–×§ ×‘×™×•×ª×¨ ×©×œ×š (×”×¤×¨×“×” ×©×œ 1.6)
            sharedWords: Math.min(60, sharedWordsSeparation * 40), // ×¢×“ 60%
            
            // ××—×™×¨ - ×’× ×—×©×•×‘ ××¦×œ×š (×”×¤×¨×“×” ×©×œ 0.1)
            priceRatio: Math.min(25, priceSeparation * 250), // ×¢×“ 25%
            
            // ××•×ª×’ - ×œ× ××•×¢×™×œ ××¦×œ×š (50% ×“×™×•×§)
            sameBrand: brandAccuracy > 0.7 ? 15 : 5, // ×¨×§ 5% ×× ×œ× ××•×¢×™×œ
            
            // ×™×—×™×“×ª ××™×“×” - ×‘×™× ×•× ×™ ××¦×œ×š
            sameUnit: unitAccuracy > 0.6 ? 10 : 5,
        },
        
        // ×¡×¤×™× ××‘×•×¡×¡×™× ×¢×œ ×”× ×ª×•× ×™× ×©×œ×š
        minSharedWords: Math.max(2, Math.round(avgGoodSharedWords * 0.7)), // ×œ×¤×—×•×ª 70% ××”×××•×¦×¢ ×”×˜×•×‘ ×©×œ×š (1.8)
        
        // ×˜×•×•×— ××—×™×¨×™× ××”× ×ª×•× ×™× ×©×œ×š (×˜×•×‘×™×: 0.94, ×¨×¢×™×: 1.04)
        priceRange: {
            min: Math.max(0.5, avgGoodPriceRatio - 0.3), // 0.64
            max: Math.min(1.5, avgBadPriceRatio + 0.2), // 1.24
            ideal: avgGoodPriceRatio, // 0.94
            badAvg: avgBadPriceRatio // 1.04
        },
        
        // ×—×•×§×™× ×¡×¤×¦×™×¤×™×™× ×©× ×œ××“×• ××”×œ×•×’ ×©×œ×š
        specificRules: extractSpecificRules(trainingData),
        
        // ×”×’×“×¨×•×ª ××™×›×•×ª - ××—××™×¨×•×ª ×™×•×ª×¨ ×›×™ ×”× ×ª×•× ×™× ×©×œ×š ×‘×¨×•×¨×™×
        qualityThreshold: 70, // ×’×‘×•×” ×™×•×ª×¨ ×›×™ ×™×© ×œ×š ×“××˜×” ×˜×•×‘×”
        maxAlternatives: 3, // ×¤×—×•×ª ××‘×œ ××™×›×•×ª×™×™× ×™×•×ª×¨
        confidenceBonus: metadata.goodDecisions > 15 ? 10 : 0, // ×‘×•× ×•×¡ ×œ×“××˜×” ×¢×©×™×¨×”
        
        // ×‘×•× ×•×¡ ×œ××™×œ×™× ××©×•×ª×¤×•×ª ×’×‘×•×”×•×ª (×”×ª×•×‘× ×” ×”×—×–×§×” ×©×œ×š)
        sharedWordsBonus: avgGoodSharedWords >= 2.5 ? 15 : 0
    };

    displayLearningAnalysis();
}
        
        function extractSpecificRules(trainingData) {
            const rules = {
                avoidPatterns: [],
                preferPatterns: [],
                brandExceptions: [],
                categorySpecific: []
            };
            
            // ×–×™×”×•×™ ×“×¤×•×¡×™× ×©×™×© ×œ×”×™×× ×¢ ××”×
            const badCases = trainingData.filter(d => d.decision === 'bad');
            badCases.forEach(badCase => {
                // ×× ×–×” ××•×ª×• ××•×ª×’ ××‘×œ ×”×•×—×œ×˜ ×©×–×” ×¨×¢ - ×™×© ×‘×¢×™×” ×¡×¤×¦×™×¤×™×ª
                if (badCase.factors.sameBrand && badCase.factors.sharedWordsCount >= 2) {
                    rules.avoidPatterns.push({
                        type: 'different_usage',
                        example: `${badCase.baseProduct} â‰  ${badCase.candidateProduct}`,
                        reason: '××•×ª×• ××•×ª×’ ××‘×œ ×©×™××•×© ×©×•× ×”'
                    });
                }
                
                // ××—×™×¨×™× ×™×§×¨×™× ××“×™
                if (badCase.factors.priceRatio > 1.2) {
                    rules.avoidPatterns.push({
                        type: 'too_expensive',
                        threshold: badCase.factors.priceRatio,
                        reason: '×™×•×ª×¨ ×™×§×¨ ×-20%'
                    });
                }
            });
            
            // ×–×™×”×•×™ ×“×¤×•×¡×™× ××•×¢×“×¤×™×
            const goodCases = trainingData.filter(d => d.decision === 'good');
            const goodWithDifferentBrands = goodCases.filter(g => !g.factors.sameBrand);
            if (goodWithDifferentBrands.length > 0) {
                rules.preferPatterns.push({
                    type: 'cross_brand_ok',
                    examples: goodWithDifferentBrands.slice(0, 2).map(g => 
                        `${g.baseProduct} â†’ ${g.candidateProduct}`
                    ),
                    reason: '××•×ª×’×™× ×©×•× ×™× ××§×•×‘×œ×™× ×‘×ª× ××™× ××¡×•×™××™×'
                });
            }
            
            return rules;
        }

        function startProcessing() {
            document.getElementById('step2').classList.add('hidden');
            document.getElementById('step3').classList.remove('hidden');
            
            processProductsWithAlternatives();
        }

        async function processProductsWithAlternatives() {
            const products = productsData.products;
            const productIds = Object.keys(products);
            const totalProducts = productIds.length;
            
            let processedCount = 0;
            const results = { ...products };
            const stats = {
                totalProducts: totalProducts,
                productsWithAlternatives: 0,
                totalAlternativesCreated: 0,
                categoryMatches: 0,
                averageQualityScore: 0,
                processingTime: Date.now()
            };

            updateProgress(0, '××ª×—×™×œ ×¢×™×‘×•×“ ××•×¦×¨×™×...');

            // ×¢×™×‘×•×“ ×›×œ ××•×¦×¨
            for (let i = 0; i < productIds.length; i++) {
                const productId = productIds[i];
                const product = products[productId];
                
                // ×—×™×¤×•×© ×ª×—×œ×™×¤×™× ×œ××•×¦×¨
                const alternatives = findSmartAlternatives(product, products, learnedRules);
                
                // ×”×•×¡×¤×ª ×”×ª×—×œ×™×¤×™× ×œ××•×¦×¨
                results[productId] = {
                    ...product,
                    smartAlternatives: alternatives,
                    alternativesCount: alternatives.length,
                    hasQualityAlternatives: alternatives.some(alt => alt.qualityScore >= learnedRules.qualityThreshold)
                };

                // ×¢×“×›×•×Ÿ ×¡×˜×˜×™×¡×˜×™×§×•×ª
                if (alternatives.length > 0) {
                    stats.productsWithAlternatives++;
                    stats.totalAlternativesCreated += alternatives.length;
                    
                    const avgScore = alternatives.reduce((sum, alt) => sum + alt.qualityScore, 0) / alternatives.length;
                    stats.averageQualityScore += avgScore;
                }

                if (product.smartCategory === learnedRules.category) {
                    stats.categoryMatches++;
                }

                processedCount++;
                const progress = (processedCount / totalProducts) * 100;
                
                // ×¢×“×›×•×Ÿ ×××©×§ ×›×œ 50 ××•×¦×¨×™×
                if (processedCount % 50 === 0 || processedCount === totalProducts) {
                    updateProgress(progress, `×¢×™×‘×•×“ ××•×¦×¨ ${processedCount}/${totalProducts}`);
                    addProcessingDetail(`âœ… ${product.itemName} - ${alternatives.length} ×ª×—×œ×™×¤×™× × ××¦××•`);
                    
                    // ×”×©×”×™×” ×§×¦×¨×” ×œ×××©×§
                    await new Promise(resolve => setTimeout(resolve, 10));
                }
            }

            // ×—×™×©×•×‘ ×¡×˜×˜×™×¡×˜×™×§×•×ª ×¡×•×¤×™×•×ª
            stats.averageQualityScore = stats.productsWithAlternatives > 0 ? 
                stats.averageQualityScore / stats.productsWithAlternatives : 0;
            stats.processingTime = Date.now() - stats.processingTime;

            // ×©××™×¨×ª ×ª×•×¦××•×ª
            processedProducts = {
                metadata: {
                    ...productsData.metadata,
                    alternativesEngine: {
                        version: "1.0",
                        basedOnCategory: learnedRules.category,
                        trainingDecisions: learnedRules.totalTrainingDecisions,
                        processingDate: new Date().toISOString(),
                        processingStats: stats,
                        learnedRules: learnedRules
                    }
                },
                products: results
            };

            // ××¢×‘×¨ ×œ×ª×•×¦××•×ª
            document.getElementById('step3').classList.add('hidden');
            document.getElementById('step4').classList.remove('hidden');
            displayResults(stats);
        }

        function findSmartAlternatives(targetProduct, allProducts, rules) {
            const alternatives = [];
            const targetCategory = targetProduct.smartCategory || targetProduct.category;
            
            // ×¨×§ ××•×¦×¨×™× ×××•×ª×” ×§×˜×’×•×¨×™×”
            const categoryProducts = Object.values(allProducts).filter(product => 
                product.itemCode !== targetProduct.itemCode &&
                (product.smartCategory || product.category) === targetCategory
            );

            for (const candidate of categoryProducts) {
                const score = calculateAlternativeScore(targetProduct, candidate, rules);
                
                if (score >= rules.qualityThreshold) {
                    alternatives.push({
                        itemCode: candidate.itemCode,
                        itemName: candidate.itemName,
                        manufacturer: candidate.manufacturer,
                        qualityScore: Math.round(score),
                        matchReason: generateMatchReason(targetProduct, candidate, rules),
                        priceComparison: calculatePriceComparison(targetProduct, candidate),
                        confidence: score >= 80 ? 'high' : score >= 65 ? 'medium' : 'low'
                    });
                }
            }

            // ××™×•×Ÿ ×œ×¤×™ ××™×›×•×ª ×•××’×‘×œ×” ×¢×œ ×›××•×ª
            return alternatives
                .sort((a, b) => b.qualityScore - a.qualityScore)
                .slice(0, rules.maxAlternatives);
        }
function calculateAlternativeScore(target, candidate, rules) {
    let score = 0;
    let bonuses = 0;

    // ××™×œ×™× ××©×•×ª×¤×•×ª - ×”×¤×§×˜×•×¨ ×”×—×©×•×‘ ×‘×™×•×ª×¨ ××”×œ×•×’ ×©×œ×š
    const targetWords = target.itemName.toLowerCase().split(/\s+/).filter(w => w.length > 2);
    const candidateWords = candidate.itemName.toLowerCase().split(/\s+/).filter(w => w.length > 2);
    const sharedWords = targetWords.filter(word => candidateWords.includes(word));
    
    // ×× ××™×Ÿ ××™×œ×™× ××©×•×ª×¤×•×ª - ×“×œ×’ ×œ×’××¨×™ (×ª×•×‘× ×” ××”×œ×•×’ ×©×œ×š)
    if (sharedWords.length === 0) {
        return 0; // ×œ× ×¨×œ×•×•× ×˜×™ ×‘×›×œ×œ
    }
    
    // ×¦×™×•×Ÿ ××™×œ×™× ××©×•×ª×¤×•×ª ××ª×§×“×
    if (sharedWords.length >= rules.minSharedWords) {
        const wordScore = (sharedWords.length / Math.max(targetWords.length, candidateWords.length)) * rules.weights.sharedWords;
        score += wordScore;
        
        // ×‘×•× ×•×¡ ×œ××™×œ×™× ××©×•×ª×¤×•×ª ×’×‘×•×”×•×ª (××”×œ×•×’ ×©×œ×š: ×˜×•×‘×™× = 2.6 ×××•×¦×¢)
        if (sharedWords.length >= 3) {
            bonuses += rules.sharedWordsBonus || 10;
        }
    }

    // ×™×—×¡ ××—×™×¨×™× - ××”×œ×•×’ ×©×œ×š: ×˜×•×‘×™× = 0.94, ×¨×¢×™× = 1.04
    const priceRatio = calculatePriceRatio(target, candidate);
    if (priceRatio >= rules.priceRange.min && priceRatio <= rules.priceRange.max) {
        // ×‘×•× ×•×¡ ×œ××•×¦×¨×™× ×–×•×œ×™× ×™×•×ª×¨ (×ª×•×‘× ×” ××”×œ×•×’ ×©×œ×š)
        if (priceRatio <= 1.0) {
            const priceScore = (1.2 - priceRatio) * rules.weights.priceRatio;
            score += priceScore;
            bonuses += 5; // ×‘×•× ×•×¡ ×œ×–×•×œ ×™×•×ª×¨
        } else {
            const priceScore = (1.5 - priceRatio) * rules.weights.priceRatio;
            score += priceScore;
        }
    } else if (priceRatio > rules.priceRange.max) {
        // ×§× ×¡ ×›×‘×“ ×œ××•×¦×¨×™× ×™×§×¨×™× ××“×™
        score -= 20;
    }

    // ××•×ª×’ ×–×”×” - ××©×§×œ × ××•×š ××”×œ×•×’ ×©×œ×š (50% ×“×™×•×§ ×‘×œ×‘×“)
    if (target.manufacturer === candidate.manufacturer && target.manufacturer.trim() !== '') {
        score += rules.weights.sameBrand;
    }

    // ×™×—×™×“×ª ××™×“×” ×–×”×”
    if (target.unitOfMeasure === candidate.unitOfMeasure) {
        score += rules.weights.sameUnit;
    }

    // ×”×•×¡×¤×ª ×‘×•× ×•×¡×™×
    score += bonuses;

    return Math.min(score, 100);
}
        
        function extractSpecificRulesFromLog(trainingData) {
    const rules = {
        avoidPatterns: [],
        preferPatterns: [],
        brandExceptions: [],
        categorySpecific: []
    };
    
    // ×–×™×”×•×™ ××•×¦×¨×™× ×œ× ×¨×œ×•×•× ×˜×™×™× (0 ××™×œ×™× ××©×•×ª×¤×•×ª)
    const irrelevantCases = trainingData.filter(d => d.decision === 'bad' && d.factors.sharedWordsCount === 0);
    if (irrelevantCases.length > 0) {
        rules.avoidPatterns.push({
            type: 'irrelevant_products',
            threshold: 0,
            reason: '×“×œ×’ ×¢×œ ××•×¦×¨×™× ×œ×œ× ××™×œ×™× ××©×•×ª×¤×•×ª',
            examples: irrelevantCases.slice(0, 2).map(c => `${c.baseProduct} â‰  ${c.candidateProduct}`)
        });
    }
    
    // ×–×™×”×•×™ ×‘×¢×™×•×ª ×¢× ××•×ª×• ××•×ª×’ (×›××• ×™×˜×‘×ª×”)
    const sameBrandBad = trainingData.filter(d => 
        d.decision === 'bad' && 
        d.factors.sameBrand && 
        d.factors.sharedWordsCount >= 1
    );
    if (sameBrandBad.length > 0) {
        rules.avoidPatterns.push({
            type: 'same_brand_different_purpose',
            reason: '××•×ª×• ××•×ª×’ ×œ× ××‘×˜×™×— ×”×ª×××”',
            examples: sameBrandBad.slice(0, 2).map(c => `${c.baseProduct} â‰  ${c.candidateProduct}`)
        });
    }
    
    // ×–×™×”×•×™ ×ª×—×œ×™×¤×™× ×˜×•×‘×™× ×¢× ××•×ª×’×™× ×©×•× ×™×
    const differentBrandGood = trainingData.filter(d => 
        d.decision === 'good' && 
        !d.factors.sameBrand && 
        d.factors.sharedWordsCount >= 2
    );
    if (differentBrandGood.length > 0) {
        rules.preferPatterns.push({
            type: 'cross_brand_with_shared_words',
            examples: differentBrandGood.slice(0, 2).map(g => 
                `${g.baseProduct} â†’ ${g.candidateProduct} (${g.factors.sharedWordsCount} ××™×œ×™×)`
            ),
            reason: '××•×ª×’×™× ×©×•× ×™× ×‘×¡×“×¨ ×× ×™×© ××™×œ×™× ××©×•×ª×¤×•×ª'
        });
    }
    
    return rules;
}

            // 4. ×™×—×¡ ××—×™×¨×™×
            const priceRatio = calculatePriceRatio(target, candidate);
            if (priceRatio >= rules.priceRange.min && priceRatio <= rules.priceRange.max) {
                const distanceFromIdeal = Math.abs(priceRatio - rules.priceRange.ideal);
                const maxDistance = Math.max(rules.priceRange.ideal - rules.priceRange.min, 
                                           rules.priceRange.max - rules.priceRange.ideal);
                const priceScore = (1 - distanceFromIdeal / maxDistance) * rules.weights.priceRatio;
                score += priceScore;
            }

            return Math.min(score, 100);
        }

        function calculatePriceRatio(target, candidate) {
            const targetPrice = getAveragePrice(target);
            const candidatePrice = getAveragePrice(candidate);
            
            return targetPrice > 0 ? candidatePrice / targetPrice : 1;
        }

        function getAveragePrice(product) {
            const prices = Object.values(product.prices || {})
                .filter(p => p.available && p.price > 0)
                .map(p => p.price);
            
            return prices.length > 0 ? prices.reduce((a, b) => a + b, 0) / prices.length : 0;
        }

        function generateMatchReason(target, candidate, rules) {
            const reasons = [];
            
            if (target.manufacturer === candidate.manufacturer && target.manufacturer.trim() !== '') {
                reasons.push('××•×ª×• ××•×ª×’');
            }
            
            if (target.unitOfMeasure === candidate.unitOfMeasure) {
                reasons.push('××•×ª×” ×™×—×™×“×ª ××™×“×”');
            }

            const targetWords = target.itemName.toLowerCase().split(/\s+/);
            const candidateWords = candidate.itemName.toLowerCase().split(/\s+/);
            const sharedWords = targetWords.filter(word => candidateWords.includes(word));
            
            if (sharedWords.length >= rules.minSharedWords) {
                reasons.push(`${sharedWords.length} ××™×œ×™× ××©×•×ª×¤×•×ª`);
            }

            const priceRatio = calculatePriceRatio(target, candidate);
            if (priceRatio <= 1.0) {
                reasons.push('××—×™×¨ ×“×•××” ××• ×–×•×œ ×™×•×ª×¨');
            }

            return reasons.length > 0 ? reasons.join(', ') : '×ª×—×œ×™×£ ××™×›×•×ª×™';
        }

        function calculatePriceComparison(target, candidate) {
            const targetPrice = getAveragePrice(target);
            const candidatePrice = getAveragePrice(candidate);
            
            if (targetPrice === 0 || candidatePrice === 0) {
                return { type: 'unknown', ratio: 1, difference: 0 };
            }

            const ratio = candidatePrice / targetPrice;
            const difference = candidatePrice - targetPrice;
            
            let type = 'similar';
            if (ratio < 0.9) type = 'cheaper';
            else if (ratio > 1.1) type = 'expensive';

            return {
                type: type,
                ratio: ratio,
                difference: difference,
                targetPrice: targetPrice,
                candidatePrice: candidatePrice
            };
        }

        function updateProgress(percent, status) {
            document.getElementById('progressBar').style.width = percent + '%';
            document.getElementById('processingStatus').textContent = status;
        }

        function addProcessingDetail(detail) {
            const detailsDiv = document.getElementById('processingDetails');
            const div = document.createElement('div');
            div.textContent = detail;
            div.className = 'text-xs text-gray-600 mb-1';
            detailsDiv.appendChild(div);
            detailsDiv.scrollTop = detailsDiv.scrollHeight;
        }

        function displayResults(stats) {
            // ×¡×˜×˜×™×¡×˜×™×§×•×ª
            document.getElementById('finalStats').innerHTML = `
                <div class="text-sm space-y-1">
                    <div>ğŸ“¦ ${stats.totalProducts} ××•×¦×¨×™× ×¢×•×‘×“×•</div>
                    <div>âœ… ${stats.productsWithAlternatives} ×§×™×‘×œ×• ×ª×—×œ×™×¤×™× (${(stats.productsWithAlternatives/stats.totalProducts*100).toFixed(1)}%)</div>
                    <div>ğŸ”— ${stats.totalAlternativesCreated} ×ª×—×œ×™×¤×™× × ×•×¦×¨×•</div>
                    <div>ğŸ¯ ${stats.categoryMatches} ××§×˜×’×•×¨×™×™×ª ×”×œ××™×“×”</div>
                    <div>â­ ${stats.averageQualityScore.toFixed(1)} ×¦×™×•×Ÿ ××™×›×•×ª ×××•×¦×¢</div>
                    <div>â±ï¸ ${(stats.processingTime/1000).toFixed(1)} ×©× ×™×•×ª ×¢×™×‘×•×“</div>
                </div>
            `;

            // ×—×•×§×™× ×©× ×œ××“×•
            document.getElementById('learnedRules').innerHTML = `
                <div class="text-sm space-y-1">
                    <div>ğŸ·ï¸ ××©×§×œ ××•×ª×’: ${learnedRules.weights.sameBrand.toFixed(1)}%</div>
                    <div>ğŸ“ ××©×§×œ ×™×—×™×“×ª ××™×“×”: ${learnedRules.weights.sameUnit.toFixed(1)}%</div>
                    <div>ğŸ“ ××©×§×œ ××™×œ×™×: ${learnedRules.weights.sharedWords.toFixed(1)}%</div>
                    <div>ğŸ’° ××©×§×œ ××—×™×¨: ${learnedRules.weights.priceRatio}%</div>
                    <div>ğŸ¯ ×¡×£ ××™×›×•×ª: ${learnedRules.qualityThreshold}%</div>
                </div>
            `;

            // ×“×•×’×××•×ª ×ª×—×œ×™×¤×™×
            const examples = findExampleAlternatives();
            document.getElementById('exampleAlternatives').innerHTML = examples;
        }

        function findExampleAlternatives() {
            const products = processedProducts.products;
            const examples = [];

            for (const [productId, product] of Object.entries(products)) {
                if (product.smartAlternatives && product.smartAlternatives.length > 0) {
                    examples.push({
                        original: product.itemName,
                        alternatives: product.smartAlternatives.slice(0, 2)
                    });
                    
                    if (examples.length >= 3) break;
                }
            }

            return examples.map(example => `
                <div class="text-sm border-b border-yellow-200 pb-2 mb-2 last:border-b-0">
                    <div class="font-semibold">${example.original}</div>
                    ${example.alternatives.map(alt => 
                        `<div class="text-gray-600 mr-4">â†’ ${alt.itemName} (${alt.qualityScore}% ××™×›×•×ª)</div>`
                    ).join('')}
                </div>
            `).join('');
        }

        function downloadResults() {
            if (processedProducts) {
                // ×”×•×¨×“×ª ×§×•×‘×¥ ×”-JSON
                const dataStr = JSON.stringify(processedProducts, null, 2);
                const dataBlob = new Blob([dataStr], {type: 'application/json'});
                
                const link = document.createElement('a');
                link.href = URL.createObjectURL(dataBlob);
                link.download = 'products_with_smart_alternatives.json';
                link.click();
            }
        }

        function downloadHTML() {
            // ×”×•×¨×“×ª ×”××¨×˜×™×¤×§×˜ ×›-HTML
            const htmlContent = document.documentElement.outerHTML;
            const htmlBlob = new Blob([htmlContent], {type: 'text/html'});
            
            const link = document.createElement('a');
            link.href = URL.createObjectURL(htmlBlob);
            link.download = 'smart_alternatives_processor.html';
            link.click();
        }

        function resetAll() {
            productsData = null;
            tinderReport = null;
            learnedRules = null;
            processedProducts = null;
            
            document.getElementById('step4').classList.add('hidden');
            document.getElementById('step1').classList.remove('hidden');
            
            document.getElementById('productsStatus').innerHTML = '×‘×—×¨ products_with_categories.json';
            document.getElementById('tinderStatus').innerHTML = '×‘×—×¨ tinder_report.json';
            document.getElementById('progressBar').style.width = '0%';
            document.getElementById('processingDetails').innerHTML = '';
        }
    </script>
</body>
</html>
